import { Injectable } from '@nestjs/common'
import { InjectRepository } from '@nestjs/typeorm'
import { Repository } from 'typeorm'
import { isDefined, filterValues } from './utils'
import Base from './entity'

type Id = Pick<Base, 'id'>

// Base service factory
// Creates a generic service class for a specific type
export default <
  // Type of the entity for the service
  EntityType,
  // One-to-many relations keys
  OneToManyKeys extends never | keyof EntityType = never,
  // Many-to-One relations keys
  ManyToOneKeys extends never | keyof EntityType = never
>(
  // Entity for the service
  Entity: new () => EntityType,
) => {
  // Type of the entity's data
  type DataType = Omit<
    // Type of entity
    EntityType,
    // Without Base & relations keys
    keyof Base | OneToManyKeys | ManyToOneKeys
  > &
    // With many-to-one keys as numbers (ids)
    { [K in ManyToOneKeys]: number }

  // Type of options
  // Subtype of TypeORM's FindOptions
  type GetOptions = { relations?: ManyToOneKeys[] }

  // Base service class
  // To be extended by specific business service class
  @Injectable()
  class BaseService {
    constructor(
      @InjectRepository(Entity)
      protected readonly repository: Repository<EntityType>,
    ) {}

    // Returns all entities of this type from the database
    async all({ relations }: GetOptions = {}): Promise<EntityType[]> {
      return this.repository.find({ relations: relations as string[] })
    }

    // Returns an entity by id from the database
    async get(
      id: number,
      { relations }: GetOptions = {},
    ): Promise<EntityType | null> {
      return await this.repository.findOne(id, {
        relations: relations as string[],
      })
    }

    // Stores an entity with data in the database
    async create(
      data: DataType,
      options: GetOptions = {},
    ): Promise<EntityType> {
      const { id } = await this.repository.save(data as any) // Should be safe

      return this.get(id, options)
    }

    // Updates an entity by id with data in the database
    async update(
      data: Id & Partial<DataType>,
      options: GetOptions = {},
    ): Promise<EntityType | null> {
      const { id } = data
      await this.repository.update(id, filterValues(isDefined)(data))

      return this.get(id, options)
    }

    // Deletes an entity by id from the database
    async delete(id: number): Promise<number> {
      await this.repository.delete(id)

      return id
    }
  }

  return (BaseService as unknown) as new () => {
    repository: Repository<EntityType>
  } & {
    [key in keyof BaseService]: BaseService[key]
  }
}
